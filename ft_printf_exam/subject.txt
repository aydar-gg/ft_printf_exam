Название работы : ft_printf
Ожидаемые файлы : ft_printf.c
Разрешенные виды использования: Танос, бесплатно, написать, va_start, как va_arg, va_copy, помощью va_end
--------------------------------------------------------------------------------

Напишите функцию с именем `ft_printf`, которая будет имитировать реальный printf со следующими ограничениями:

- Он будет управлять только следующими преобразованиями: s,d и x
- Он будет управлять минимальной шириной поля. (мы никогда не будем тестировать с полем с 0)
- Он будет управлять только флагом precison `.`.

Ваша функция должна быть объявлена следующим образом:

int ft_printf(const char *, ... );

Прежде чем начать, мы советуем вам прочитать "man 3 printf" и "man va_arg".
Чтобы протестировать вашу программу, сравните ваши результаты с истинным printf.

Исключения из вывода функции:

вызов: ft_printf("%10.2 s\n", "toto");
из: США

звоните: ft_printf("Волшебная %s является %5d", "количество", 42);
выход:магическое число-42%

звоните: ft_printf("шестнадцатеричное %d %х\н", 42, 42);
out:шестнадцатеричное значение для 42 равно 2a$

Название работы : get_next_line
Ожидаемые файлы : get_next_line.c get_next_line.х
Разрешенные функции: read, free, malloc
--------------------------------------------------------------------------------

Написать функцию, будет магазин, в строке "параметр", линия, которая была прочитана из файла с дескриптором 0.

Ваша функция должна быть прототипирована следующим образом: int get_next_line(char **line);

Ваша функция должна быть свободна от утечки памяти.

То, что мы называем "прочитанной строкой", представляет собой последовательность от 0 до n символов, которые заканчиваются на '\n' (код ascii 0x0a) или на конец файла (EOF).

Строка, хранящаяся в параметре "line", не должна содержать никаких '\n'.

Параметр - это адрес указателя на символ, который будет использоваться для хранения прочитанной строки.

Возвращаемое значение может быть 1, 0 или -1 в зависимости от того, была ли прочитана строка, когда чтение было завершено (то есть чтение вернуло 0) или произошла ошибка соответственно.

Когда вы дойдете до конца файла, вы должны сохранить текущий буфер в "строке". Если буфер пуст, вы должны сохранить пустую строку в "строке".

Когда Вы дойдете до конца файла, ваша функция должна сохранить 0 памяти, выделенной с помощью malloc, за исключением последнего буфера, который вы должны были сохранить в "строке".

То, что вы сохранили в "строке", должно быть свободно.

Таким образом, вызов функции get_next_line в цикле позволит вам читать текст, доступный в файловом дескрипторе, по одной строке за раз до конца текста, независимо от размера текста или одной из его строк.

Убедитесь, что ваша функция ведет себя хорошо, когда она читает из файла, из стандартного вывода, из перенаправления и т. д.

Ни один вызов другой функции не будет выполнен на файловом дескрипторе между 2 вызовами get_next_line.

Наконец, мы считаем, что get_next_line имеет неопределенное поведение при чтении из двоичного файла.

Вы должны использовать test.sh чтобы помочь вам проверить вашу get_next_line.
